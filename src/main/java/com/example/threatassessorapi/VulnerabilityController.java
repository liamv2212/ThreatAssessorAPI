package com.example.threatassessorapi;

import org.apache.coyote.BadRequestException;
import org.springframework.web.bind.annotation.*;

import java.sql.*;
import java.time.LocalDate;
import java.util.ArrayList;
import java.util.Objects;

import static com.example.threatassessorapi.SQLHelpers.*;

@RestController
@CrossOrigin
@RequestMapping(path = "/vulnerabilities")
public class VulnerabilityController {
    @GetMapping(
            path="/",
            produces = "application/json")
    private static ArrayList<Vulnerability> findAllVulnerabilities(@RequestParam("org_id") int orgId,
                                                                   @RequestParam(value = "OS", required = false) String OS,
                                                                   @RequestParam(value = "resource_type", required = false) String resource_type,
                                                                   @RequestParam(value = "criticality", required = false) String criticality,
                                                                   @RequestParam(value = "start_date", required = false) Long startDate,
                                                                   @RequestParam(value = "end_date", required = false) Long endDate) throws BadRequestException {
        var vulnerabilities = new ArrayList<Vulnerability>();
        try(Connection connection = ResourceDB.connect();
            Statement statement = connection.createStatement()) {
            String query = "select DISTINCT resource_id, vulnerability_name, " +
                    "organization_id, risk_score, criticality, remediation_steps, first_found from resource " +
                    "inner join vulnerabilities using (resource_id, organization_id) " +
                    "where organization_id = " + orgId + getOSFilter(OS)
                    + getResourceTypeFilter(resource_type) + getDateFilter(startDate, endDate) + getCriticalityFilter(criticality) + " ORDER BY risk_score desc";
            System.out.println(query);
            ResultSet rs = statement.executeQuery(query);
            while (rs.next()) {
                var vuln = new Vulnerability(
                        rs.getString("vulnerability_name"),
                        rs.getInt("resource_id"),
                        rs.getInt("organization_id"),
                        rs.getInt("risk_score"),
                        rs.getString("criticality"),
                        rs.getString("remediation_steps"),
                        rs.getDate("first_found"));
                vulnerabilities.add(vuln);
            }
        }catch (Exception e) {
            System.err.println(e.getMessage());
            throw new BadRequestException(e.getMessage());
        }
        return vulnerabilities;
    }

    @GetMapping(
            path="/count",
            produces = "application/json")
    private static ArrayList<DatedInteger> countAllVulnerabilities(@RequestParam("org_id") int orgId,
                                                                   @RequestParam(value = "OS", required = false) String OS,
                                                                   @RequestParam(value = "criticality", required = false) String criticality,
                                                                   @RequestParam(value = "resource_type", required = false) String resource_type,
                                                                   @RequestParam(value = "start_date", required = false) Long startDate,
                                                                   @RequestParam(value = "end_date", required = false) Long endDate) throws BadRequestException {
        var vulnCount = new ArrayList<DatedInteger>();
        ArrayList<LocalDate> startDates = new ArrayList<>();
        ArrayList<LocalDate> endDates = new ArrayList<>();
        if(!Objects.isNull(endDate)){
            if (!Objects.isNull(startDate)) {
                LocalDate end = getEndDate(endDate);
                startDates = getStartDates(startDate, end);
                endDates = getEndDates(startDates);
            }
            else throw new BadRequestException("Start date is required to use End Date");
        }
        else {
            LocalDate end = toMonday(LocalDate.now());
            if (!Objects.isNull(startDate)) {
                startDates = getStartDates(startDate, end);
            }
            else startDates.add(toMonday(LocalDate.now().minusWeeks(1)));
            endDates = getEndDates(startDates);

        }
        try(Connection connection = ResourceDB.connect();
            Statement statement = connection.createStatement()) {
            for(int i = 0; i < startDates.size(); i++){
            ResultSet rs = statement.executeQuery("select COUNT(DISTINCT vulnerability_name) from resource " +
                    "inner join vulnerabilities using (resource_id, organization_id) " +
                    "where organization_id = " + orgId + getOSFilter(OS)
                    + getResourceTypeFilter(resource_type) + getHistoricalDateString(startDates.get(i), endDates.get(i)) + getCriticalityFilter(criticality));
                vulnCount.add(getDatedInteger(rs, endDates.get(i), "count"));
            }
        }catch (Exception e) {
            System.err.println(e.getMessage());
            throw new BadRequestException(e.getMessage());
        }
        return vulnCount;
    }

    @GetMapping(
            path="/{id}",
            produces = "application/json")
    private static ArrayList<Vulnerability> findResourceVulnerabilities(@RequestParam("org_id") int orgId,
                                                                        @PathVariable("id") int id,
                                                                        @RequestParam(value = "OS", required = false) String OS,
                                                                        @RequestParam(value = "criticality", required = false) String criticality,
                                                                        @RequestParam(value = "resource_type", required = false) String resource_type,
                                                                        @RequestParam(value = "start_date", required = false) Long startDate,
                                                                        @RequestParam(value = "end_date", required = false) Long endDate) throws SQLException, BadRequestException {
        var vulnerabilities = new ArrayList<Vulnerability>();
        try(Connection connection = ResourceDB.connect();
            Statement statement = connection.createStatement()) {
            String query = "select Distinct resource_id, vulnerability_name," +
                    "organization_id, risk_score, criticality, remediation_steps, first_found from resource " +
                    "inner join vulnerabilities using (resource_id, organization_id) " +
                    "where organization_id = " + orgId +
                    " and resource_id = " + id + getDateFilter(startDate, endDate) + getCriticalityFilter(criticality) + getOSFilter(OS) + getResourceTypeFilter(resource_type);
            ResultSet rs = statement.executeQuery(query);
            while (rs.next()) {
                var vuln = new Vulnerability(
                        rs.getString("vulnerability_name"),
                        rs.getInt("resource_id"),
                        rs.getInt("organization_id"),
                        rs.getInt("risk_score"),
                        rs.getString("criticality"),
                        rs.getString("remediation_steps"),
                        rs.getDate("first_found")
                        );
                vulnerabilities.add(vuln);
            }
        }catch (Exception e) {
            System.err.println(e.getMessage());
            throw new BadRequestException(e.getMessage());

        }
        return vulnerabilities;
    }

    @GetMapping(
            path="/risk",
            produces = "application/json")
    private static ArrayList<DatedInteger> getRiskScore(@RequestParam("org_id") int orgId,
                                                        @RequestParam(value = "OS", required = false) String OS,
                                                        @RequestParam(value = "resource_type", required = false) String resource_type,
                                                        @RequestParam(value = "criticality", required = false) String criticality,
                                                        @RequestParam(value = "start_date", required = false) Long startDate,
                                                        @RequestParam(value = "end_date", required = false) Long endDate) throws SQLException, BadRequestException {
        ArrayList<DatedInteger> riskScores = new ArrayList<>();
        ArrayList<LocalDate> startDates = new ArrayList<>();
        ArrayList<LocalDate> endDates = new ArrayList<>();
        if(!Objects.isNull(endDate)){
            if (!Objects.isNull(startDate)) {
                LocalDate end = getEndDate(endDate);
                startDates = getStartDates(startDate, end);
                endDates = getEndDates(startDates);
            }
            else throw new BadRequestException("Start date is required to use End Date");
        }
        else {
            LocalDate end = toMonday(LocalDate.now());
            if (!Objects.isNull(startDate)) {
                startDates = getStartDates(startDate, end);
            }
            else startDates.add(toMonday(LocalDate.now().minusWeeks(1)));
            endDates = getEndDates(startDates);

        }
        try (Connection connection = ResourceDB.connect();
             Statement statement = connection.createStatement()) {
            for (int i = 0; i < startDates.size(); i++) {
                String query = "SELECT AVG(risk_score) as risk_score FROM resource " +
                        "inner join vulnerabilities using (resource_id, organization_id) " +
                        "where organization_id = " + orgId
                        + getOSFilter(OS) + getResourceTypeFilter(resource_type) + getHistoricalDateString(startDates.get(i), endDates.get(i)) + getCriticalityFilter(criticality);
                ResultSet rs = statement.executeQuery(query);
                riskScores.add(getDatedInteger(rs, endDates.get(i), "risk_score"));
            }
        } catch (Exception ex) {
            System.err.println(ex.getMessage());
            throw new BadRequestException(ex.getMessage());

        }
        return riskScores;
    }

    @GetMapping(
            path="/risk/{id}",
            produces = "application/json")
    private static ArrayList<DatedInteger> getRiskScore(@RequestParam("org_id") int orgId,
                                                        @PathVariable("id") int id,
                                                        @RequestParam(value = "OS", required = false) String OS,
                                                        @RequestParam(value = "criticality", required = false) String criticality,
                                                        @RequestParam(value = "resource_type", required = false) String resource_type,
                                                        @RequestParam(value = "start_date", required = false) Long startDate,
                                                        @RequestParam(value = "end_date", required = false) Long endDate) throws SQLException, BadRequestException {
        ArrayList<DatedInteger> riskScores = new ArrayList<>();
        ArrayList<LocalDate> startDates = new ArrayList<>();
        ArrayList<LocalDate> endDates = new ArrayList<>();
        if(!Objects.isNull(endDate)){
            if (!Objects.isNull(startDate)) {
                LocalDate end = getEndDate(endDate);
                startDates = getStartDates(startDate, end);
                endDates = getEndDates(startDates);
            }
            else throw new BadRequestException("Start date is required to use End Date");
        }
        else {
            LocalDate end = toMonday(LocalDate.now());
            if (!Objects.isNull(startDate)) {
                startDates = getStartDates(startDate, end);
            }
            else startDates.add(toMonday(LocalDate.now().minusWeeks(1)));
            endDates = getEndDates(startDates);

        }
        try (Connection connection = ResourceDB.connect();
             Statement statement = connection.createStatement()) {
            for (int i = 0; i < startDates.size(); i++) {
                String query = "SELECT AVG(risk_score) as risk_score FROM resource " +
                        "inner join vulnerabilities using (resource_id, organization_id) " +
                        "where organization_id = " + orgId + " " +
                        "AND resource_id = " + id + getHistoricalDateString(startDates.get(i), endDates.get(i)) + getCriticalityFilter(criticality) +getOSFilter(OS) + getResourceTypeFilter(resource_type);
                ResultSet rs = statement.executeQuery(query);
                riskScores.add(getDatedInteger(rs, endDates.get(i), "risk_score"));
            }
        } catch (Exception ex) {
            System.err.println(ex.getMessage());
            throw new BadRequestException(ex.getMessage());
        }
        return riskScores;
    }

    @GetMapping(
            path="/remediated",
            produces = "application/json")
    private static ArrayList<DatedInteger> getRemediatedVulnCount(@RequestParam("org_id") int orgId,
                                                                  @RequestParam(value = "OS", required = false) String OS,
                                                                  @RequestParam(value = "criticality", required = false) String criticality,
                                                                  @RequestParam(value = "resource_type", required = false) String resource_type,
                                                                  @RequestParam(value = "start_date", required = false) Long startDate,
                                                                  @RequestParam(value = "end_date", required = false) Long endDate) throws SQLException, BadRequestException {

        ArrayList<DatedInteger> datedCounts = new ArrayList<>();
        DatedInteger datedCount;
        ArrayList<LocalDate> startDates = new ArrayList<>();
        ArrayList<LocalDate> endDates = new ArrayList<>();
        if(!Objects.isNull(endDate)){
            if (!Objects.isNull(startDate)) {
                LocalDate end = getEndDate(endDate);
                startDates = getStartDates(startDate, end);
                endDates = getEndDates(startDates);
            }
            else throw new BadRequestException("Start date is required to use End Date");
        }
        else {
            LocalDate end = toMonday(LocalDate.now());
            if (!Objects.isNull(startDate)) {
                startDates = getStartDates(startDate, end);
            }
            else startDates.add(toMonday(LocalDate.now().minusWeeks(1)));
            endDates = getEndDates(startDates);

        }
        try (Connection connection = ResourceDB.connect();
             Statement statement = connection.createStatement()) {
            for (int i = 0; i < startDates.size(); i++) {
                String query = "WITH v1 as (SELECT * FROM vulnerabilities inner join resource using (resource_id, organization_id) " +
                        "WHERE organization_id = " + orgId + getHistoricalDateString(startDates.get(i), endDates.get(i)) + getOSFilter(OS) + getResourceTypeFilter(resource_type) + getCriticalityFilter(criticality) + ")," +
                        "v2 as (select vulnerability_name from vulnerabilities where partition_date ='" + endDates.get(i) + "' and organization_id = "+ orgId + ") " +
                        "Select COUNT(DISTINCT v1.vulnerability_name) count from v1 " +
                        "left join v2 on v1.vulnerability_name = v2.vulnerability_name where v2.vulnerability_name IS NULL";
                System.out.println(query);
                ResultSet rs = statement.executeQuery(query);
                datedCounts.add(getDatedInteger(rs, endDates.get(i), "count"));
            }
        } catch (Exception ex) {
            System.err.println(ex.getMessage());
            throw new BadRequestException(ex.getMessage());

        }
        return datedCounts;
    }

    @GetMapping(
            path="/newlyFoundCount",
            produces = "application/json")
    private static ArrayList<DatedInteger> getNewlyFoundVulnCount(@RequestParam("org_id") int orgId,
                                                                  @RequestParam(value = "OS", required = false) String OS,
                                                                  @RequestParam(value = "resource_type", required = false) String resource_type,
                                                                  @RequestParam(value = "criticality", required = false) String criticality,
                                                                  @RequestParam(value = "start_date", required = false) Long startDate,
                                                                  @RequestParam(value = "end_date", required = false) Long endDate) throws SQLException, BadRequestException {
        ArrayList<DatedInteger> datedCounts = new ArrayList<>();
        ArrayList<LocalDate> startDates = new ArrayList<>();
        if(!Objects.isNull(endDate)){
            if (!Objects.isNull(startDate)) {
                LocalDate end = getEndDate(endDate);
                startDates = getStartDates(startDate, end);
            }
            else throw new BadRequestException("Start date is required to use End Date");
        }
        else {
            LocalDate end = toMonday(LocalDate.now());
            if (!Objects.isNull(startDate)) {
                startDates = getNewlyFoundStartDates(startDate, end);
            }
            else startDates.add(toMonday(LocalDate.now()));

        }
        try (Connection connection = ResourceDB.connect();
             Statement statement = connection.createStatement()) {
            for (LocalDate date : startDates) {
                String query = "select count(vulnerability_id) count from vulnerabilities inner join resource using (resource_id, organization_id) where organization_id = " + orgId + getOSFilter(OS) + getResourceTypeFilter(resource_type) + " AND first_found = '" + date + "'" + getCriticalityFilter(criticality);
                ResultSet rs = statement.executeQuery(query);
                datedCounts.add(getDatedInteger(rs, date, "count"));
            }
        } catch (Exception ex) {
            System.err.println(ex.getMessage());
            throw new BadRequestException(ex.getMessage());

        }
        return datedCounts;
    }

    @GetMapping(
            path="/newlyFound",
            produces = "application/json")
    private static ArrayList<Vulnerability> getNewlyFoundVulns(@RequestParam("org_id") int orgId,
                                                               @RequestParam(value = "OS", required = false) String OS,
                                                               @RequestParam(value = "resource_type", required = false) String resource_type,
                                                               @RequestParam(value = "criticality", required = false) String criticality,
                                                               @RequestParam(value = "start_date", required = false) Long startDate,
                                                               @RequestParam(value = "end_date", required = false) Long endDate) throws SQLException, BadRequestException {
        ArrayList<Vulnerability> vulnerabilities = new ArrayList<>();
        ArrayList<LocalDate> startDates = new ArrayList<>();
        if(!Objects.isNull(endDate)){
            if (!Objects.isNull(startDate)) {
                LocalDate end = getEndDate(endDate);
                startDates = getStartDates(startDate, end);
            }
            else throw new BadRequestException("Start date is required to use End Date");
        }
        else {
            LocalDate end = toMonday(LocalDate.now());
            if (!Objects.isNull(startDate)) {
                startDates = getNewlyFoundStartDates(startDate, end);
            }
            else startDates.add(toMonday(LocalDate.now().minusWeeks(1)));

        }
        try (Connection connection = ResourceDB.connect();
             Statement statement = connection.createStatement()) {
            for (LocalDate date : startDates) {
                String query = "select vulnerability_id, vulnerability_name, resource_id, organization_id, risk_score, criticality,remediation_steps, first_found, partition_date  from vulnerabilities inner join resource using (resource_id, organization_id) where organization_id = " + orgId + getOSFilter(OS) + getResourceTypeFilter(resource_type) + " AND first_found = '" + date + "'" + getCriticalityFilter(criticality);
                ResultSet rs = statement.executeQuery(query);
                while(rs.next()){
                    var vuln = new Vulnerability(
                            rs.getInt("vulnerability_id"),
                            rs.getString("vulnerability_name"),
                            rs.getInt("resource_id"),
                            rs.getInt("organization_id"),
                            rs.getInt("risk_score"),
                            rs.getString("criticality"),
                            rs.getString("remediation_steps"),
                            rs.getDate("first_found"),
                            rs.getDate("partition_date"));
                    vulnerabilities.add(vuln);
                }
            }
        } catch (Exception ex) {
            System.err.println(ex.getMessage());
            throw new BadRequestException(ex.getMessage());

        }
        return vulnerabilities;
    }

    @GetMapping(
            path="/mttr",
            produces = "application/json")
    private static int getMTTR(@RequestParam("org_id") int orgId,
                                                               @RequestParam(value = "OS", required = false) String OS,
                                                               @RequestParam(value = "resource_type", required = false) String resource_type,
                                                               @RequestParam(value = "criticality", required = false) String criticality) throws SQLException, BadRequestException {
        int mttr = 0;
        try (Connection connection = ResourceDB.connect();
             Statement statement = connection.createStatement()) {
                String query = "with max_dates as (SELECT vulnerability_name, max(partition_date) as max_date, first_found FROM resource\n" +
                        " inner join vulnerabilities" +
"                         using (resource_id, organization_id)" +
                        " WHERE partition_date IN (select partition_date from vulnerabilities)" +
                        " and organization_id = " + orgId + getOSFilter(OS) + getResourceTypeFilter(resource_type) + getCriticalityFilter(criticality) +
                        " AND partition_date < '" + toMonday(LocalDate.now()) + "'" +
                        " group by vulnerability_name, first_found)" +
                        "SELECT avg(max_date::date - first_found::date) AS MTTR from max_dates";
                ResultSet rs = statement.executeQuery(query);
                while(rs.next()){
                    mttr = rs.getInt("mttr");
            }
        } catch (Exception ex) {
            System.err.println(ex.getMessage());
            throw new BadRequestException(ex.getMessage());

        }
        return mttr;
    }

    @GetMapping(
            path="/countCritical",
            produces = "application/json")
    private static Integer findAllCriticalVulnerabilities(@RequestParam("org_id") int orgId) throws BadRequestException {
        Integer count = 0;
        try(Connection connection = ResourceDB.connect();
            Statement statement = connection.createStatement()) {
            String query = "with vulns as (select DISTINCT resource_id, vulnerability_name, " +
                    "organization_id, risk_score, criticality, first_found from resource " +
                    "inner join vulnerabilities using (resource_id, organization_id) " +
                    "where organization_id = " + orgId + ") select count(*) from vulns where criticality = 'Critical'";
            ResultSet rs = statement.executeQuery(query);
            while (rs.next()) {
                count = rs.getInt("count");
            }
        }catch (Exception e) {
            System.err.println(e.getMessage());
            throw new BadRequestException(e.getMessage());
        }
        return count;
    }

    @GetMapping(
            path="/countHigh",
            produces = "application/json")
    private static Integer findAllHighVulnerabilities(@RequestParam("org_id") int orgId) throws BadRequestException {
        Integer count = 0;
        try(Connection connection = ResourceDB.connect();
            Statement statement = connection.createStatement()) {
            String query = "with vulns as (select DISTINCT resource_id, vulnerability_name, " +
                    "organization_id, risk_score, criticality, first_found from resource " +
                    "inner join vulnerabilities using (resource_id, organization_id) " +
                    "where organization_id = " + orgId + ") select count(*) from vulns where criticality = 'High'";
            ResultSet rs = statement.executeQuery(query);
            while (rs.next()) {
                count = rs.getInt("count");
            }
        }catch (Exception e) {
            System.err.println(e.getMessage());
            throw new BadRequestException(e.getMessage());
        }
        return count;
    }

    @GetMapping(
            path="/countMedium",
            produces = "application/json")
    private static Integer findAllMediumVulnerabilities(@RequestParam("org_id") int orgId) throws BadRequestException {
        Integer count = 0;
        try(Connection connection = ResourceDB.connect();
            Statement statement = connection.createStatement()) {
            String query = "with vulns as (select DISTINCT resource_id, vulnerability_name, " +
                    "organization_id, risk_score, criticality, first_found from resource " +
                    "inner join vulnerabilities using (resource_id, organization_id) " +
                    "where organization_id = " + orgId + ") select count(*) from vulns where criticality = 'Medium'";
            ResultSet rs = statement.executeQuery(query);
            while (rs.next()) {
                count = rs.getInt("count");
            }
        }catch (Exception e) {
            System.err.println(e.getMessage());
            throw new BadRequestException(e.getMessage());
        }
        return count;
    }

    @GetMapping(
            path="/countLow",
            produces = "application/json")
    private static Integer findAllLowVulnerabilities(@RequestParam("org_id") int orgId) throws BadRequestException {
        Integer count = 0;
        try(Connection connection = ResourceDB.connect();
            Statement statement = connection.createStatement()) {
            String query = "with vulns as (select DISTINCT resource_id, vulnerability_name, " +
                    "organization_id, risk_score, criticality, first_found from resource " +
                    "inner join vulnerabilities using (resource_id, organization_id) " +
                    "where organization_id = " + orgId + ") select count(*) from vulns where criticality = 'Low'";
            ResultSet rs = statement.executeQuery(query);
            while (rs.next()) {
                count = rs.getInt("count");
            }
        }catch (Exception e) {
            System.err.println(e.getMessage());
            throw new BadRequestException(e.getMessage());
        }
        return count;
    }

    @GetMapping(
            path="/countInfo",
            produces = "application/json")
    private static Integer findAllInfoVulnerabilities(@RequestParam("org_id") int orgId) throws BadRequestException {
        Integer count = 0;
        try(Connection connection = ResourceDB.connect();
            Statement statement = connection.createStatement()) {
            String query = "with vulns as (select DISTINCT resource_id, vulnerability_name, " +
                    "organization_id, risk_score, criticality, remediation_steps, first_found from resource " +
                    "inner join vulnerabilities using (resource_id, organization_id) " +
                    "where organization_id = " + orgId + ") select count(*) from vulns where criticality = 'Info'";
            ResultSet rs = statement.executeQuery(query);
            while (rs.next()) {
                count = rs.getInt("count");
            }
        }catch (Exception e) {
            System.err.println(e.getMessage());
            throw new BadRequestException(e.getMessage());
        }
        return count;
    }

}
