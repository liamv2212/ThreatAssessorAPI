package com.example.threatassessorapi;

import org.apache.coyote.BadRequestException;
import org.springframework.cglib.core.Local;
import org.springframework.web.bind.annotation.*;

import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.time.Instant;
import java.time.LocalDate;
import java.time.ZoneId;
import java.util.ArrayList;
import java.util.Objects;

import static com.example.threatassessorapi.SQLHelpers.*;

@RestController
@RequestMapping(path = "/vulnerabilities")
public class VulnerabilityController {
    @GetMapping(
            path="/",
            produces = "application/json")
    private static ArrayList<Vulnerability> findAllVulnerabilities(@RequestParam("org_id") int orgId,
                                                                   @RequestParam(value = "OS", required = false) String OS,
                                                                   @RequestParam(value = "resource_type", required = false) String resource_type,
                                                                   @RequestParam(value = "start_date", required = false) Long startDate,
                                                                   @RequestParam(value = "end_date", required = false) Long endDate) throws BadRequestException {
        var vulnerabilities = new ArrayList<Vulnerability>();
        try(Connection connection = ResourceDB.connect();
            Statement statement = connection.createStatement()) {
            ResultSet rs = statement.executeQuery("select resource_id, vulnerability_id, vulnerability_name, " +
                    "organization_id, risk_score, first_found, partition_date from resource " +
                    "inner join vulnerabilities using (resource_id, organization_id) " +
                    "where organization_id = " + orgId + getOSFilter(OS)
                    + getResourceTypeFilter(resource_type) + getDateFilter(startDate, endDate));
            while (rs.next()) {
                var vuln = new Vulnerability(
                        rs.getInt("vulnerability_id"),
                        rs.getString("vulnerability_name"),
                        rs.getInt("resource_id"),
                        rs.getInt("organization_id"),
                        rs.getInt("risk_score"),
                        rs.getDate("first_found"),
                        rs.getDate("partition_date"));
                vulnerabilities.add(vuln);
            }
        }catch (Exception e) {
            System.err.println(e.getMessage());
            throw new BadRequestException(e.getMessage());
        }
        return vulnerabilities;
    }

    @GetMapping(
            path="/{id}",
            produces = "application/json")
    private static ArrayList<Vulnerability> findResourceVulnerabilities(@RequestParam("org_id") int orgId,
                                                                        @PathVariable("id") int id,
                                                                        @RequestParam(value = "start_date", required = false) Long startDate,
                                                                        @RequestParam(value = "end_date", required = false) Long endDate) throws SQLException, BadRequestException {
        var vulnerabilities = new ArrayList<Vulnerability>();
        try(Connection connection = ResourceDB.connect();
            Statement statement = connection.createStatement()) {
            String query = "select resource_id, vulnerability_id, vulnerability_name," +
                    "organization_id, risk_score, first_found, partition_date from resource " +
                    "inner join vulnerabilities using (resource_id, organization_id) " +
                    "where organization_id = " + orgId +
                    " and resource_id = " + id + getDateFilter(startDate, endDate);
            ResultSet rs = statement.executeQuery(query);
            while (rs.next()) {
                var vuln = new Vulnerability(
                        rs.getInt("vulnerability_id"),
                        rs.getString("vulnerability_name"),
                        rs.getInt("resource_id"),
                        rs.getInt("organization_id"),
                        rs.getInt("risk_score"),
                        rs.getDate("first_found"),
                        rs.getDate("partition_date"));
                vulnerabilities.add(vuln);
            }
        }catch (Exception e) {
            System.err.println(e.getMessage());
            throw new BadRequestException(e.getMessage());

        }
        return vulnerabilities;
    }

    @GetMapping(
            path="/risk",
            produces = "application/json")
    private static Integer getRiskScore(@RequestParam("org_id") int orgId,
                                        @RequestParam(value = "OS", required = false) String OS,
                                        @RequestParam(value = "resource_type", required = false) String resource_type,
                                        @RequestParam(value = "start_date", required = false) Long startDate,
                                        @RequestParam(value = "end_date", required = false) Long endDate) throws SQLException, BadRequestException {
        int riskScore = 0;
        try (Connection connection = ResourceDB.connect();
             Statement statement = connection.createStatement()) {
            String query = "SELECT AVG(risk_score) as risk_score FROM resource " +
                    "inner join vulnerabilities using (resource_id, organization_id) " +
                    "where organization_id = " + orgId
                    + getOSFilter(OS) + getResourceTypeFilter(resource_type) + getDateFilter(startDate, endDate);
            ResultSet rs = statement.executeQuery(query);
            while (rs.next()) {
                riskScore = rs.getInt("risk_score");
            }
        } catch (Exception ex) {
            System.err.println(ex.getMessage());
            throw new BadRequestException(ex.getMessage());

        }
        return riskScore;
    }

    @GetMapping(
            path="/risk/{id}",
            produces = "application/json")
    private static Integer getRiskScore(@RequestParam("org_id") int orgId,
                                        @PathVariable("id") int id,
                                        @RequestParam(value = "start_date", required = false) Long startDate,
                                        @RequestParam(value = "end_date", required = false) Long endDate) throws SQLException, BadRequestException {
        int riskScore = 0;
        try (Connection connection = ResourceDB.connect();
             Statement statement = connection.createStatement()) {
            String query = "SELECT AVG(risk_score) as risk_score FROM resource " +
                    "inner join vulnerabilities using (resource_id, organization_id) " +
                    "where organization_id = " + orgId + " " +
                    "AND resource_id = " + id + getDateFilter(startDate, endDate);
            ResultSet rs = statement.executeQuery(query);
            while (rs.next()) {
                riskScore = rs.getInt("risk_score");
            }
        } catch (Exception ex) {
            System.err.println(ex.getMessage());
            throw new BadRequestException(ex.getMessage());
        }
        return riskScore;
    }

    @GetMapping(
            path="/remediated",
            produces = "application/json")
    private static Integer getRemediatedVulnCount(@RequestParam("org_id") int orgId,
                                        @RequestParam(value = "OS", required = false) String OS,
                                        @RequestParam(value = "resource_type", required = false) String resource_type,
                                        @RequestParam(value = "start_date", required = false) Long startDate) throws SQLException, BadRequestException {
        LocalDate next = null;
        LocalDate start = null;
        int count = 0;
        try (Connection connection = ResourceDB.connect();
             Statement statement = connection.createStatement()) {
            if (!Objects.isNull(startDate)){
                Instant instant = Instant.ofEpochMilli(startDate);
                ZoneId zoneId = ZoneId.systemDefault();
                start = toMonday(instant.atZone(zoneId).toLocalDate());
                next = start.plusWeeks(1);
            }
            else {
                next = toMonday(LocalDate.now());
                start = next.minusWeeks(1);
            }
            String query = "WITH v1 as (SELECT * FROM vulnerabilities " +
                    "WHERE organization_id = " + orgId + " and partition_date in ('" + start +
                    "','" + next + "'))," +
                    "v2 as (select vulnerability_name from vulnerabilities where partition_date ='" + next + "' and organization_id = "+ orgId + ") Select COUNT(DISTINCT v1.vulnerability_name) count from v1 " +
                    "left join v2 on v1.vulnerability_name = v2.vulnerability_name where v2.vulnerability_name IS NULL";
            ResultSet rs = statement.executeQuery(query);
            while (rs.next()) {
                count = rs.getInt("count");            }
        } catch (Exception ex) {
            System.err.println(ex.getMessage());
            throw new BadRequestException(ex.getMessage());

        }
        return count;
    }
}
