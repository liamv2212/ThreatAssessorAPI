package com.example.threatassessorapi;

import org.apache.coyote.BadRequestException;
import org.springframework.web.bind.annotation.*;

import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.ArrayList;

import static com.example.threatassessorapi.SQLHelpers.*;

@RestController
@RequestMapping(path = "/vulnerabilities")
public class VulnerabilityController {
    @GetMapping(
            path="/",
            produces = "application/json")
    private static ArrayList<Vulnerability> findAllVulnerabilities(@RequestParam("org_id") int orgId,
                                                                   @RequestParam(value = "OS", required = false) String OS,
                                                                   @RequestParam(value = "resource_type", required = false) String resource_type,
                                                                   @RequestParam(value = "start_date", required = false) Long startDate,
                                                                   @RequestParam(value = "end_date", required = false) Long endDate) throws BadRequestException {
        var vulnerabilities = new ArrayList<Vulnerability>();
        try(Connection connection = ResourceDB.connect();
            Statement statement = connection.createStatement()) {
            ResultSet rs = statement.executeQuery("select resource_id, vulnerability_id, vulnerability_name, " +
                    "organization_id, risk_score, first_found, partition_date from resource " +
                    "inner join vulnerabilities using (resource_id, organization_id) " +
                    "where organization_id = " + orgId + getOSFilter(OS)
                    + getResourceTypeFilter(resource_type) + getDateFilter(startDate, endDate));
            while (rs.next()) {
                var vuln = new Vulnerability(
                        rs.getInt("vulnerability_id"),
                        rs.getString("vulnerability_name"),
                        rs.getInt("resource_id"),
                        rs.getInt("organization_id"),
                        rs.getInt("risk_score"),
                        rs.getDate("first_found"),
                        rs.getDate("partition_date"));
                vulnerabilities.add(vuln);
            }
        }catch (Exception e) {
            throw new BadRequestException(e.getMessage());
        }
        return vulnerabilities;
    }

    @GetMapping(
            path="/{id}",
            produces = "application/json")
    private static ArrayList<Vulnerability> findResourceVulnerabilities(@RequestParam("org_id") int orgId,
                                                                        @PathVariable("id") int id,
                                                                        @RequestParam(value = "start_date", required = false) Long startDate,
                                                                        @RequestParam(value = "end_date", required = false) Long endDate) throws SQLException, BadRequestException {
        var vulnerabilities = new ArrayList<Vulnerability>();
        try(Connection connection = ResourceDB.connect();
            Statement statement = connection.createStatement()) {
            String query = "select resource_id, vulnerability_id, vulnerability_name," +
                    "organization_id, risk_score, first_found, partition_date from resource " +
                    "inner join vulnerabilities using (resource_id, organization_id) " +
                    "where organization_id = " + orgId + " " +
                    "and resource_id = " + id + getDateFilter(startDate, endDate);
            System.out.println(query);
            ResultSet rs = statement.executeQuery(query);
            while (rs.next()) {
                var vuln = new Vulnerability(
                        rs.getInt("vulnerability_id"),
                        rs.getString("vulnerability_name"),
                        rs.getInt("resource_id"),
                        rs.getInt("organization_id"),
                        rs.getInt("risk_score"),
                        rs.getDate("first_found"),
                        rs.getDate("partition_date"));
                vulnerabilities.add(vuln);
            }
        }catch (Exception e) {
            throw new BadRequestException(e.getMessage());

        }
        return vulnerabilities;
    }

    @GetMapping(
            path="/risk",
            produces = "application/json")
    private static Integer getRiskScore(@RequestParam("org_id") int orgId,
                                        @RequestParam(value = "OS", required = false) String OS,
                                        @RequestParam(value = "resource_type", required = false) String resource_type,
                                        @RequestParam(value = "start_date", required = false) Long startDate,
                                        @RequestParam(value = "end_date", required = false) Long endDate) throws SQLException, BadRequestException {
        int riskScore = 0;
        try (Connection connection = ResourceDB.connect();
             Statement statement = connection.createStatement()) {
            String query = "SELECT AVG(risk_score) as risk_score FROM resource " +
                    "inner join vulnerabilities using (resource_id, organization_id) " +
                    "where organization_id = " + orgId
                    + getOSFilter(OS) + getResourceTypeFilter(resource_type) + getDateFilter(startDate, endDate);
            ResultSet rs = statement.executeQuery(query);
            while (rs.next()) {
                riskScore = rs.getInt("risk_score");
            }
        } catch (Exception ex) {
            throw new BadRequestException(ex.getMessage());

        }
        return riskScore;
    }

    @GetMapping(
            path="/risk/{id}",
            produces = "application/json")
    private static Integer getRiskScore(@RequestParam("org_id") int orgId,
                                        @PathVariable("id") int id,
                                        @RequestParam(value = "start_date", required = false) Long startDate,
                                        @RequestParam(value = "end_date", required = false) Long endDate) throws SQLException, BadRequestException {
        int riskScore = 0;
        try (Connection connection = ResourceDB.connect();
             Statement statement = connection.createStatement()) {
            String query = "SELECT AVG(risk_score) as risk_score FROM resource " +
                    "inner join vulnerabilities using (resource_id, organization_id) " +
                    "where organization_id = " + orgId + " " +
                    "AND resource_id = " + id + getDateFilter(startDate, endDate);
            ResultSet rs = statement.executeQuery(query);
            while (rs.next()) {
                riskScore = rs.getInt("risk_score");
            }
        } catch (Exception ex) {
            throw new BadRequestException(ex.getMessage());
        }
        return riskScore;
    }
}
