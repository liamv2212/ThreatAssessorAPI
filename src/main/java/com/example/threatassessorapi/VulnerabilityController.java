package com.example.threatassessorapi;

import org.apache.coyote.BadRequestException;
import org.springframework.web.bind.annotation.*;

import java.sql.*;
import java.time.LocalDate;
import java.util.ArrayList;
import java.util.Objects;

import static com.example.threatassessorapi.SQLHelpers.*;

@RestController
@CrossOrigin
@RequestMapping(path = "/vulnerabilities")
public class VulnerabilityController {
    @GetMapping(
            path="/",
            produces = "application/json")
    private static ArrayList<Vulnerability> findAllVulnerabilities(@RequestParam("org_id") int orgId,
                                                                   @RequestParam(value = "OS", required = false) String OS,
                                                                   @RequestParam(value = "resource_type", required = false) String resource_type,
                                                                   @RequestParam(value = "start_date", required = false) Long startDate,
                                                                   @RequestParam(value = "end_date", required = false) Long endDate) throws BadRequestException {
        var vulnerabilities = new ArrayList<Vulnerability>();
        try(Connection connection = ResourceDB.connect();
            Statement statement = connection.createStatement()) {
            ResultSet rs = statement.executeQuery("select resource_id, vulnerability_id, vulnerability_name, " +
                    "organization_id, risk_score, first_found, partition_date from resource " +
                    "inner join vulnerabilities using (resource_id, organization_id) " +
                    "where organization_id = " + orgId + getOSFilter(OS)
                    + getResourceTypeFilter(resource_type) + getDateFilter(startDate, endDate));
            while (rs.next()) {
                var vuln = new Vulnerability(
                        rs.getInt("vulnerability_id"),
                        rs.getString("vulnerability_name"),
                        rs.getInt("resource_id"),
                        rs.getInt("organization_id"),
                        rs.getInt("risk_score"),
                        rs.getDate("first_found"),
                        rs.getDate("partition_date"));
                vulnerabilities.add(vuln);
            }
        }catch (Exception e) {
            System.err.println(e.getMessage());
            throw new BadRequestException(e.getMessage());
        }
        return vulnerabilities;
    }

    @GetMapping(
            path="/count",
            produces = "application/json")
    private static ArrayList<DatedInteger> countAllVulnerabilities(@RequestParam("org_id") int orgId,
                                                                   @RequestParam(value = "OS", required = false) String OS,
                                                                   @RequestParam(value = "resource_type", required = false) String resource_type,
                                                                   @RequestParam(value = "start_date", required = false) Long startDate,
                                                                   @RequestParam(value = "end_date", required = false) Long endDate) throws BadRequestException {
        var vulnCount = new ArrayList<DatedInteger>();
        ArrayList<LocalDate> startDates = new ArrayList<>();
        ArrayList<LocalDate> endDates = new ArrayList<>();
        if(!Objects.isNull(endDate)){
            if (!Objects.isNull(startDate)) {
                LocalDate end = getEndDate(endDate);
                startDates = getStartDates(startDate, end);
                endDates = getEndDates(startDates);
            }
            else throw new BadRequestException("Start date is required to use End Date");
        }
        else {
            LocalDate end = toMonday(LocalDate.now());
            if (!Objects.isNull(startDate)) {
                startDates = getStartDates(startDate, end);
            }
            else startDates.add(toMonday(LocalDate.now().minusWeeks(1)));
            endDates = getEndDates(startDates);

        }
        try(Connection connection = ResourceDB.connect();
            Statement statement = connection.createStatement()) {
            for(int i = 0; i < startDates.size(); i++){
            ResultSet rs = statement.executeQuery("select COUNT(DISTINCT vulnerability_id) from resource " +
                    "inner join vulnerabilities using (resource_id, organization_id) " +
                    "where organization_id = " + orgId + getOSFilter(OS)
                    + getResourceTypeFilter(resource_type) + getHistoricalDateString(startDates.get(i), endDates.get(i)));
                vulnCount.add(getDatedInteger(rs, endDates.get(i), "count"));
            }
        }catch (Exception e) {
            System.err.println(e.getMessage());
            throw new BadRequestException(e.getMessage());
        }
        return vulnCount;
    }

    @GetMapping(
            path="/{id}",
            produces = "application/json")
    private static ArrayList<Vulnerability> findResourceVulnerabilities(@RequestParam("org_id") int orgId,
                                                                        @PathVariable("id") int id,
                                                                        @RequestParam(value = "start_date", required = false) Long startDate,
                                                                        @RequestParam(value = "end_date", required = false) Long endDate) throws SQLException, BadRequestException {
        var vulnerabilities = new ArrayList<Vulnerability>();
        try(Connection connection = ResourceDB.connect();
            Statement statement = connection.createStatement()) {
            String query = "select resource_id, vulnerability_id, vulnerability_name," +
                    "organization_id, risk_score, first_found, partition_date from resource " +
                    "inner join vulnerabilities using (resource_id, organization_id) " +
                    "where organization_id = " + orgId +
                    " and resource_id = " + id + getDateFilter(startDate, endDate);
            ResultSet rs = statement.executeQuery(query);
            while (rs.next()) {
                var vuln = new Vulnerability(
                        rs.getInt("vulnerability_id"),
                        rs.getString("vulnerability_name"),
                        rs.getInt("resource_id"),
                        rs.getInt("organization_id"),
                        rs.getInt("risk_score"),
                        rs.getDate("first_found"),
                        rs.getDate("partition_date"));
                vulnerabilities.add(vuln);
            }
        }catch (Exception e) {
            System.err.println(e.getMessage());
            throw new BadRequestException(e.getMessage());

        }
        return vulnerabilities;
    }

    @GetMapping(
            path="/risk",
            produces = "application/json")
    private static ArrayList<DatedInteger> getRiskScore(@RequestParam("org_id") int orgId,
                                        @RequestParam(value = "OS", required = false) String OS,
                                        @RequestParam(value = "resource_type", required = false) String resource_type,
                                        @RequestParam(value = "start_date", required = false) Long startDate,
                                        @RequestParam(value = "end_date", required = false) Long endDate) throws SQLException, BadRequestException {
        ArrayList<DatedInteger> riskScores = new ArrayList<>();
        ArrayList<LocalDate> startDates = new ArrayList<>();
        ArrayList<LocalDate> endDates = new ArrayList<>();
        if(!Objects.isNull(endDate)){
            if (!Objects.isNull(startDate)) {
                LocalDate end = getEndDate(endDate);
                startDates = getStartDates(startDate, end);
                endDates = getEndDates(startDates);
            }
            else throw new BadRequestException("Start date is required to use End Date");
        }
        else {
            LocalDate end = toMonday(LocalDate.now());
            if (!Objects.isNull(startDate)) {
                startDates = getStartDates(startDate, end);
            }
            else startDates.add(toMonday(LocalDate.now().minusWeeks(1)));
            endDates = getEndDates(startDates);

        }
        try (Connection connection = ResourceDB.connect();
             Statement statement = connection.createStatement()) {
            for (int i = 0; i < startDates.size(); i++) {
                String query = "SELECT AVG(risk_score) as risk_score FROM resource " +
                        "inner join vulnerabilities using (resource_id, organization_id) " +
                        "where organization_id = " + orgId
                        + getOSFilter(OS) + getResourceTypeFilter(resource_type) + getHistoricalDateString(startDates.get(i), endDates.get(i));
                ResultSet rs = statement.executeQuery(query);
                riskScores.add(getDatedInteger(rs, endDates.get(i), "risk_score"));
            }
        } catch (Exception ex) {
            System.err.println(ex.getMessage());
            throw new BadRequestException(ex.getMessage());

        }
        return riskScores;
    }

    @GetMapping(
            path="/risk/{id}",
            produces = "application/json")
    private static ArrayList<DatedInteger> getRiskScore(@RequestParam("org_id") int orgId,
                                        @PathVariable("id") int id,
                                        @RequestParam(value = "start_date", required = false) Long startDate,
                                        @RequestParam(value = "end_date", required = false) Long endDate) throws SQLException, BadRequestException {
        ArrayList<DatedInteger> riskScores = new ArrayList<>();
        ArrayList<LocalDate> startDates = new ArrayList<>();
        ArrayList<LocalDate> endDates = new ArrayList<>();
        if(!Objects.isNull(endDate)){
            if (!Objects.isNull(startDate)) {
                LocalDate end = getEndDate(endDate);
                startDates = getStartDates(startDate, end);
                endDates = getEndDates(startDates);
            }
            else throw new BadRequestException("Start date is required to use End Date");
        }
        else {
            LocalDate end = toMonday(LocalDate.now());
            if (!Objects.isNull(startDate)) {
                startDates = getStartDates(startDate, end);
            }
            else startDates.add(toMonday(LocalDate.now().minusWeeks(1)));
            endDates = getEndDates(startDates);

        }
        try (Connection connection = ResourceDB.connect();
             Statement statement = connection.createStatement()) {
            for (int i = 0; i < startDates.size(); i++) {
                String query = "SELECT AVG(risk_score) as risk_score FROM resource " +
                        "inner join vulnerabilities using (resource_id, organization_id) " +
                        "where organization_id = " + orgId + " " +
                        "AND resource_id = " + id + getHistoricalDateString(startDates.get(i), endDates.get(i));
                ResultSet rs = statement.executeQuery(query);
                riskScores.add(getDatedInteger(rs, endDates.get(i), "risk_score"));
            }
        } catch (Exception ex) {
            System.err.println(ex.getMessage());
            throw new BadRequestException(ex.getMessage());
        }
        return riskScores;
    }

    @GetMapping(
            path="/remediated",
            produces = "application/json")
    private static ArrayList<DatedInteger> getRemediatedVulnCount(@RequestParam("org_id") int orgId,
                                                                  @RequestParam(value = "OS", required = false) String OS,
                                                                  @RequestParam(value = "resource_type", required = false) String resource_type,
                                                                  @RequestParam(value = "start_date", required = false) Long startDate,
                                                                  @RequestParam(value = "end_date", required = false) Long endDate) throws SQLException, BadRequestException {

        ArrayList<DatedInteger> datedCounts = new ArrayList<>();
        DatedInteger datedCount;
        ArrayList<LocalDate> startDates = new ArrayList<>();
        ArrayList<LocalDate> endDates = new ArrayList<>();
        if(!Objects.isNull(endDate)){
            if (!Objects.isNull(startDate)) {
                LocalDate end = getEndDate(endDate);
                startDates = getStartDates(startDate, end);
                endDates = getEndDates(startDates);
            }
            else throw new BadRequestException("Start date is required to use End Date");
        }
        else {
            LocalDate end = toMonday(LocalDate.now());
            if (!Objects.isNull(startDate)) {
                startDates = getStartDates(startDate, end);
            }
            else startDates.add(toMonday(LocalDate.now().minusWeeks(1)));
            endDates = getEndDates(startDates);

        }
        try (Connection connection = ResourceDB.connect();
             Statement statement = connection.createStatement()) {
            for (int i = 0; i < startDates.size(); i++) {
                String query = "WITH v1 as (SELECT * FROM vulnerabilities inner join resource using (resource_id, organization_id) " +
                        "WHERE organization_id = " + orgId + getHistoricalDateString(startDates.get(i), endDates.get(i)) + getOSFilter(OS) + getResourceTypeFilter(resource_type) + ")," +
                        "v2 as (select vulnerability_name from vulnerabilities where partition_date ='" + endDates.get(i) + "' and organization_id = "+ orgId + ") " +
                        "Select COUNT(DISTINCT v1.vulnerability_name) count from v1 " +
                        "left join v2 on v1.vulnerability_name = v2.vulnerability_name where v2.vulnerability_name IS NULL";
                ResultSet rs = statement.executeQuery(query);
                datedCounts.add(getDatedInteger(rs, endDates.get(i), "count"));
            }
        } catch (Exception ex) {
            System.err.println(ex.getMessage());
            throw new BadRequestException(ex.getMessage());

        }
        return datedCounts;
    }

    @GetMapping(
            path="/newlyFoundCount",
            produces = "application/json")
    private static ArrayList<DatedInteger> getNewlyFoundVulnCount(@RequestParam("org_id") int orgId,
                                                                  @RequestParam(value = "OS", required = false) String OS,
                                                                  @RequestParam(value = "resource_type", required = false) String resource_type,
                                                                  @RequestParam(value = "start_date", required = false) Long startDate,
                                                                  @RequestParam(value = "end_date", required = false) Long endDate) throws SQLException, BadRequestException {
        ArrayList<DatedInteger> datedCounts = new ArrayList<>();
        ArrayList<LocalDate> startDates = new ArrayList<>();
        if(!Objects.isNull(endDate)){
            if (!Objects.isNull(startDate)) {
                LocalDate end = getEndDate(endDate);
                startDates = getStartDates(startDate, end);
            }
            else throw new BadRequestException("Start date is required to use End Date");
        }
        else {
            LocalDate end = toMonday(LocalDate.now());
            if (!Objects.isNull(startDate)) {
                startDates = getNewlyFoundStartDates(startDate, end);
            }
            else startDates.add(toMonday(LocalDate.now().minusWeeks(1)));

        }
        try (Connection connection = ResourceDB.connect();
             Statement statement = connection.createStatement()) {
            for (LocalDate date : startDates) {
                String query = "select count(vulnerability_id) count from vulnerabilities inner join resource using (resource_id, organization_id) where organization_id = " + orgId + getOSFilter(OS) + getResourceTypeFilter(resource_type) + " AND first_found = '" + date + "'";
                ResultSet rs = statement.executeQuery(query);
                datedCounts.add(getDatedInteger(rs, date, "count"));
            }
        } catch (Exception ex) {
            System.err.println(ex.getMessage());
            throw new BadRequestException(ex.getMessage());

        }
        return datedCounts;
    }

    @GetMapping(
            path="/newlyFound",
            produces = "application/json")
    private static ArrayList<Vulnerability> getNewlyFoundVulns(@RequestParam("org_id") int orgId,
                                                                  @RequestParam(value = "OS", required = false) String OS,
                                                                  @RequestParam(value = "resource_type", required = false) String resource_type,
                                                                  @RequestParam(value = "start_date", required = false) Long startDate,
                                                                  @RequestParam(value = "end_date", required = false) Long endDate) throws SQLException, BadRequestException {
        ArrayList<Vulnerability> vulnerabilities = new ArrayList<>();
        ArrayList<LocalDate> startDates = new ArrayList<>();
        if(!Objects.isNull(endDate)){
            if (!Objects.isNull(startDate)) {
                LocalDate end = getEndDate(endDate);
                startDates = getStartDates(startDate, end);
            }
            else throw new BadRequestException("Start date is required to use End Date");
        }
        else {
            LocalDate end = toMonday(LocalDate.now());
            if (!Objects.isNull(startDate)) {
                startDates = getNewlyFoundStartDates(startDate, end);
            }
            else startDates.add(toMonday(LocalDate.now().minusWeeks(1)));

        }
        try (Connection connection = ResourceDB.connect();
             Statement statement = connection.createStatement()) {
            for (LocalDate date : startDates) {
                String query = "select vulnerability_id, vulnerability_name, resource_id, organization_id, risk_score, first_found, partition_date  from vulnerabilities inner join resource using (resource_id, organization_id) where organization_id = " + orgId + getOSFilter(OS) + getResourceTypeFilter(resource_type) + " AND first_found = '" + date + "'";
                ResultSet rs = statement.executeQuery(query);
                if(rs.next()){
                    var vuln = new Vulnerability(
                            rs.getInt("vulnerability_id"),
                            rs.getString("vulnerability_name"),
                            rs.getInt("resource_id"),
                            rs.getInt("organization_id"),
                            rs.getInt("risk_score"),
                            rs.getDate("first_found"),
                            rs.getDate("partition_date"));
                    vulnerabilities.add(vuln);
                }
                else vulnerabilities.add(new Vulnerability(null, null, null, null, null, Date.valueOf(date), null));
            }
        } catch (Exception ex) {
            System.err.println(ex.getMessage());
            throw new BadRequestException(ex.getMessage());

        }
        return vulnerabilities;
    }

}
